# LITEOS
[TOC]

## 操作系统基础知识
### 实时操作系统与分时操作系统
RTOS实时 以时间为参考，对收到的信号做出“及时”实时“的反应”，规定时间，具有可靠性。典型代表：单片机嵌入式：电梯的控制
分时 多用户系统。有时间片轮转，重交互性。典型代表Linux/GUN操作系统 

### 内核线程与用户线程
#### 内核线程与用户线程对比
相同点是：
- 都由do_fork()创建，每个线程都有独立的task_struct和内核栈；
- 都参与调度，内核线程也有优先级，会被调度器平等地换入换出

不同之处在于：

- 内核线程只工作在内核态中；而用户线程则既可以运行在内核态（-执行系统调用时），也可以运行在用户态；
- 内核线程没有用户空间，所以对于一个内核线程来说，它的0~3G的内存空间是空白的，它的current->mm是空的，与内核使用同一张页表；而用户线程则可以看到完整的0~4G内存空间。

[参考](https://www.cnblogs.com/sky-heaven/p/8204614.html)
## 体系架构
## 内核架构
- 内存管理
- 内核调度
- 进程间通信
- 调试开发
## 内核功能
- 硬件相关：硬中断、硬件定时器
- 内存管理：静态动态、内存统计、泄漏检测
- 内核功能：任务管理、软件定时器
- 通信：信号量、互斥量、事件、消息队列
- 调试：内存检测、任务栈检测

## 总结文档
### 工作流程
參見[los_init]()

> 舉例
 OsExcRegister例外函数(exc)会执行
 OsExcInit例外函数初始化会设OsExcRegister
 OsTaskInit任务初始化函数会设OsExcRegister LOS_KernelInit内核初始化函数会调用OsExcInit(MAX_EXC_MEM_SIZE);
 osKernelInitialize(void)会调用LOS_KernelInit
 main()会调用osKernelInitialize(void)[最先运行的函数]
### 内存管理
los可以使用静态内存管理:不需要占用cpu资源,在编译时完成一切内存分配  
[如何选择两种管理方式](https://blog.csdn.net/Nocky/article/details/6056440?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param)
#### 静态内存管理
##### 初始化
传入参数:内存起始地址;总大小;每个块大小
分配的时候分为
- control block
  - (ptr*)free:指向第一个可用块
  - (ptr*)end:指向内存末尾
  - blksize:记录每个内存块大小
- single bulk
  - (ptr*)next:指向下一个可用块
  - content:可用空间
##### 内存申请
连续分配时,如果free!=NULL,当前存在空闲块,free=free->next
##### 内存释放
要释放的块的next指向free,free指向要释放的块
#### 动态内存管理
##### 初始化
传入参数:动态内存起始地址,内存大小
- 头部控制头
  - (ptr*)next:指向下一个控制头(初始化指向尾部控制头)
  - len:初始化=0
- 中间可分配内存
- 尾部控制头
  - (ptr*)next:指向NULL
  - len:初始化=0
##### 内存申请
- 判断内存大小是否够分 可用内存为当前动态内存大小-所有控制块大小与所有控制块len区域标志的大小. 即 第一个控制头开始用``需要申请的内存大小NeededSize（包含控制头）``和 ``HeadCtrl.next – HeadCtrl – HeadCtrl.len ``的值作比较
##### 内存释放
- 头部内存释放:仅仅将len改为0
- 中间内存释放:将其父指针指向HeadCtrl->next(原来位置的内容在分配的时候直接被覆盖)
### Task
#### 简介
- LiteOS的任务一共有32个优先级(0-31)，最高优先级为0，最低优先级为31。同一优先级任务使用双向链表管理。
- 每一个任务都含有一个任务控制块(TCB)。TCB包含了任务上下文SP、任务状态、任务优先级、任务ID、任务名、任务栈大小等信息。
- 任务切换：在**M3内核**中利用第14号PendSV异常进行任务切换。 与11号SVC异常必须在执行SVC指令后立即得到响应，如果得不到响应，会上访成硬fault不同，PendSV可以像普通的中断一样被悬起的。

#### 实现方式
流程:
> initTask:初始化所有队列:TCB队列(TASKID==表下标)
  创建某个任务
    初始化createTask的参数:taskInitParam
      编写入口函数
      任务名
      栈大小...
    CreateTask
      检查传入参数正确性 OsTaskParamCheck
      检查taskID正确性(指针地址是否无效)
      获得一个新的TCB
      初始化新task:OsNewTaskInit
        初始状态设置为suspended
      给taskID赋当前TCB的值
      唤醒task LOS_TaskResume
        关中断
        判断是否是挂起状态
        条件均满足
        开中断
        任务调度 LOS_Schedule //汇编程序  
  所有task入口 LITE_OS_SEC_TEXT_INIT VOID OsTaskEntry(UINT32 taskID)
    确认TASKID
    运行入口函数
    删除任务
      任务正在运行-状态改为unused-schedule
      任务没有被使用-放入freelist-说明是可用的
      
 #define LOS_DL_LIST_ENTRY(item, type, member) \
    ((type *)(VOID *)((CHAR *)(item) - LOS_OFF_SET_OF(type, member))) \
 #define LOS_OFF_SET_OF(type, member) ((UINT32)&(((type *)0)->member))


#### 状态
- - 就绪（资源分配完成，**仅仅等待CPU**）
  - 运行（正在被CPU执行）
  - 阻塞（任务被挂起、延迟、等待信号量、读写队列、等待读写时间）
- 任务调度：创建任务、任务挂起、任务恢复、任务延时、解锁任务调度、信号量操作
- 当前任务为最高优先级任务或锁任务调度时，任务调度会退出，不会进行任务切换

#### 功能
- 任务删除 任务创建
- 任务信息查询 LOS_TaskSelf
#### API
功能分类|接口名| 描述
 |--|--|--|
任务的创建和删除| LOS_TaskCreate| 创建任务。
| |LOS_TaskDelete| 删除指定的任务。
 |任务信息查询| LOS_TaskSelf| 获取当前任务PID。
|任务状态控制| LOS_TaskResume| 恢复挂起的任务。
| |LOS_TaskSuspend| 挂起指定的任务。
| |LOS_TaskDelay| 任务延时等待。
| |LOS_TaskYield| 显式放权，调整指定优先级的任务调度顺序。
|任务调度的控制|LOS_TaskLock|锁任务调|
| |LOS_TaskUnlock|解锁任务调度
 |任务优先级的维护| LOS_TaskPrioritySet| 设置指定任务的优先级。
||LOS_TaskPriorityGet|获取指定任务的优先级。
 

### Timer
初始化：完成内存的分配、相关参数的设置、内部逻辑结构的建立、相关数据的初始化和为处理超时处理函数创建0号优先级任务。
为了方便管理软件定时器控制块，在初始化时对定时器控制块进行申请内存空间，以数组的形式访问，从而达到定时器的快速定位，同时为了方便定时器的使用管理，把所有空闲定时器控制块以单向链表组织起来，构成一条空闲链表，当使用时直接从链表头取，回收时直接插入到链表首部。
#### 流程
初始化，创建0号超时处理函数/所有空闲定时器控制块以单向链表链接
定时器模块：计时结构sortlink，全部指向一个单向循环链表
##### 初始化 分四个部分
  **1.定时器**本体
  - 内存分配
  - 控制块数据初始化


  **2.定时器链表**
    1.初始化 osTimerCreate
    - m_pstSwTmrSortList=NULL

    2.规则
    - 定时器按照超时从早到晚排序
    - 每个tick中断对当前链表进行扫描，超时的进行处理

  **3.sortlink**设置
  - Tick当前检验的定时器链表类 初始==0
  - TimerList*指向**链表数组**首地址，每个sortlink元素指向一个单向循环链表

  **4.定时器超时回调结构内存池与队列**
  - m_aucSwTmrHandlerPool 一块8字节 4回调函数指针+4回调函数参数
  - m_uwSwTmrHandlerQueue 队列长度等于上一个的块数
  - 在tick中扫描到有定时器超时，申请一块固定大小内存块，封装放入队列
  
  **5.定时器超时处理队列与任务**
  - 超时回调队列创建完成后**创建定时器超时处理任务**
  - **定时器超时处理任务**读取队列执行回调函数 
  - 等待时间永远 
  - 根据队列内容（回调函数指针与参数）

注意：定时器回调函数中不要调用挂起定时器超时处理接任务的接口。因为串行处理，后方定时器超时后会提前调度、等待；或者使得整个队列爆满
##### 软件定时器创建 osTimerCreate
    - 调用创建接口
    - 设置属性osTimerDef：计时长度、触发模式、超时处理函数（Timer1_Callback）、超时处理参数、返回ID
##### 软件定时器启动
    - 调用接口：设置状态为 OS_SWTMR_STATUS_TICKING设定计时开始/重新开始  
    - 设置计数时间初始值为当前计时总和与
##### 软件定时器超时扫描
  - 每个Tick中断对定时器初始处理 
  - 定时器内部逻辑结构设定:每个定时器设置超时时间与计数时间，计数时间Cn采用向下减一的方式计数. 
  > n=1 Cn=Tn;
    n>1 Cn=Tn-C1-C2...-C(N-1)
    将定时器插在第一个使其Cn值不为0的地方
    可以只读第一个就判断是否存在超时定时器
  - 如果扫描到Cn==0的定时器,判断其状态:periodic(restart),once(delete)

##### 定时器删除 osTimerDelete
 
  软件定时器的删除操作是把已经处于计时或处于暂停状态的定时器进行回收，把孤立散列的控制块插入到空闲链表中，如果定时器控制块在计时链表上，则先停止，再将孤立控制块回收。
  - 用户调用软件定时器的删除接口，传入定时器ID
  - 验证其合法性
  >未使用状态（**OS_SWTMR_STATUS_UNUSED**），则返回系统错误
  计时状态（**OS_SWTMR_STATUS_TICKING**），则先停止该定时器，再将其插入到空闲链表中，并修改相应的定时器统计状态
  空闲状态（**OS_SWTMR_STATUS_CREATED**），则直接将其插入到空闲链表中，并修改状态
  最后已经删除的定时器的状态为**OS_SWTMR_STATUS_UNUSED**（空闲状态）

#### API
|功能分类|接口名|描述|
|--|--|--|
定义定时器| osTimerDef|定义定时器
获取定时器资源|osTimer|获取定时器资源
创建定时器|osTimerCreate | 创建定时器 
开启定时器 | osTimerStart | 开启定时器
停止定时器 | osTimerStop | 停止定时器
删除定时器 | osTimerDelete | 删除定时器
 

### Semaphore
信号量（Semaphore）是内核IPC通信方式的一种。信号量对象具有一个内部计数器。它支持两种原子操作：**申请（Pend）**和**释放（Post）**
- pend操作申请指定的信号量,如果其值大于0->对应信号量-1返回成功信号;如果其值等于0,任务阻塞,进入等待状态;
- post操作释放指定的信号量,没有任务等待该信号就直接将计数器加一;否则唤起挂起队列中第一个任务.
#### 信号量设计
##### 初始化
- 信号量初始化为用户配置的N个信号量申请内存，并把所有的信号量初始化成未使用，并加入到未使用链表中供系统使用。
- 若为当前用户配置的信号量为0则返回错误码
##### 信号量创建与删除
- 创建
 > 开始
 **入参合法性**
 关中断
 *检测是否有可用信号
 有:获取信号量修改其状态标志设置处置处置,开中断返回成功   没有:开中断返回失败 
 结束
- 删除
同上 *除改为检查是否有任务阻塞与当前信号
有:开中断 返回失败 无:修改标志加入未使用链表 开中断返回成功 
#### 信号量申请

任务需要Pend信号量，判断信号量计数是否大于0，若大于0则减1后成功返回，否则

- 无阻塞模式：直接返回pend失败。
- 永久阻塞模式：该任务进入阻塞态，系统切换到就绪任务中优先级最高者继续执行。任务进入阻塞态后，直到有其他任务释放该信号量，阻塞任务才会重新得以执行。
- 定时阻塞模式：同上,或是用户指定时间超时后，阻塞任务才会重新得以执行(超时后直接进行任务超时处理)。

注意:用户需要自行保证不在中断线程中使用永久阻塞和定时阻塞

#### 信号量的释放
功能分类 | 接口名 | 描述 | 
 |--|--|--|
 |信号量的创建和删除 | LOS_SemCreate | 创建信号量。 |
 | |LOS_SemDelete | 删除指定的信号量。 |
  |信号量的申请和释放 | LOS_SemPend | 申请指定的信号量。|
   |  |LOS_SemPost | 释放指定的信号量。|

### Mutex
互斥锁是一种用于**线程之间互相排斥**的装置。它通过对公共临界区的原子操作来实现保护共享数据结构的目的。
#### 互斥锁状态
- 解锁
- 加锁
#### 互斥锁设计
##### 初始化
  - 申请N个互斥锁的内存
  - 加入**未使用的信号量链表**
  
- 创建和删除
  - 创建:从未使用的互斥锁列表中获取一个互斥锁资源设定初值
  - 删除:将正在使用的互斥锁置空并挂回链表
##### 互斥锁申请
- 互斥锁申请任务需要Pend互斥锁，判断互斥锁计数是否为0，若为0则加1后成功返回，若不为0，则判断持有该互斥锁的任务是否和申请该互斥锁的任务为同一个任务，若为同一个任务，则加1后成功返回,,否则:
  - 无阻塞模式：直接返回pend失败。
  - 永久阻塞模式：该任务进入阻塞态，系统切换到就绪任务中优先级最高者继续执行。任务进入阻塞态后，直到有其他任务释放该信号量，阻塞任务才会重新得以执行。
  - 定时阻塞模式：同上,或是用户指定时间超时后，阻塞任务才会重新得以执行(超时后直接进行任务超时处理)。
  > 和信号量申请对比:互斥锁是有锁不能分配,即计数量==0是可以得到锁;而同一任务多次请求则在当前锁上加1,其他任务不饿能相加
##### 互斥锁释放
互斥锁释放操作是互斥锁申请操作的相反过程，过程中需要判断是否有任务阻塞于这个互斥锁。
- 如果有任务阻塞于指定互斥锁，则唤醒最早被阻塞的任务
  - 如果被唤醒的任务被其他线程suspend，那么该任务会从互斥锁和suspend双阻塞态和转到suspend态
  - 如果被唤醒的任务没有被其他线程suspend，那么该任务进入就绪态，并进行调度
- 如果没有任务阻塞于指定互斥锁，则对互斥锁计数加1，返回成功。
#### API 
|功能分类 | 接口名 | 描述 | 
 |--|--|--|
 |互斥锁的创建和删除 | LOS_MuxCreate | 创建互斥锁
 ||LOS_MuxDelete | 删除指定的互斥锁。 | 
|互斥锁的申请和释放 | LOS_MuxPend | 申请指定的互斥锁。 
|  |LOS_MuxPost | 释放指定的互斥锁。
 

#### 注意:
所有互斥同步的资源创建与删除都需在处理之前关中断,结束之前再开中断
### MessageQueue
#### 基础知识
LiteOS中使用队列数据结构实现任务通讯和同步工作，具有如下特性：

1. 消息以先进先出方式排队，循环使用，读写支持同步工作方式；

2. 发送消息类型为一个整形或者指针大小（不可用栈上内存）；

3. 一个任务能够从任一个队列接受和发送消息；

4. 多个任务能够从同一个消息队列接受和发送消息；

5. 当队列使用结束后，如果动态申请的内存，可以通过删除回收内存。
#### 运作机制
由队列实现:维护头指针与尾指针
- Head:已经写入的第一个可用的消息
- Tail:可以写入的空闲的消息单元
> Tail每次写入向后移动
 Tail如果指向队列末尾则重新指向队列头
 当Tail与head重合时说明队列已满,任务(写消息Task)被挂起或者写失败
 对空队列读操作也导致挂起或写失败
##### 消息发送
要点:
- 判断是否存在可用节点
- 写入消息队列后判断是都存在Task挂起在队列
- 放入就绪队列
如果有挂起
  - 挂起的队列是否等待Timer
  - 从Timer链表中移除Task  
##### 消息接收

 ##### 队列删除
 删除ID->入参合法性检查->合法:是否有Task等待;否:返回->是:是否有消息在队列中;否:返回->是:删除队列释放内存;否:返回
 #### mail 使用
 与Message不同的是：
- 内存分配/释放
Mail在创建的同时已经分配的内存，用户可以通过Mail的内存分配、释放接口来获取、释放内存。
- 任务等待内存分配
Mail在申请内存时，会因为没有内存而被挂起（在中断中不允许等待），发送时则不会引起任务等待；

## 基础知识
### 内核线程与用户线程
